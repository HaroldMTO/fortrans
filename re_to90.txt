# notes :
# - dans toutes les RE, ';' est remplacé par ':' dans rewrite.R
# - rewrite.R commence par concaténer les chaines, en supprimant aussi les '!'
# - l'ordre des RE importe, du fait de dépendances
# - RE dont les suivantes sont fortement dépendantes :
#  . suppression des tabulations et espaces de fin de ligne
#  . suppression des commentaires
#  . concaténation des lignes continuées
#  . espacement des structures de controle

# conversion tab en espace pour utiliser ' ' au lieu de '\s'
# car '\n' est dans '\s'
\t: 

# suppression include interface
\n *#include +\"[^\n]*\.intfb\.h\":

# suppression espaces de fin de ligne
 +(\n|$):\1

# suppression commentaires Fortran 90 (lignes entieres, mais lignes vides non supprimées)
(^|\n)( *!+\n+)+:\1\n
(^|\n)( *![^$d][^\n]+\n*)+:\1
(^|\n)( *!$[^o][^\n]*\n*)+:\1
(^|\n)( *!d[^ie][^\n]*\n*)+:\1

# suppression commentaires Fortran 90 (fin de ligne)
(^|\n)(( *[^\n& ]+)+&?) *!+[^\n]*:\1\2

# concaténation des lignes continuées (sur fin de ligne, sauf directives CPP)
&( *![^\n]*)*\n+ *(&|([^!])):\3
\n {5}[1-9&*+]:

# suppression espaces avant/après virgule (hors commentaires car supprimés)
 *, *:,

# suppression d'espaces avant/après opérateurs maths et affectation
 *([=,(+/*\-]) *:\1

# reespacement affectations en instruction simple
(\n *[^\n()=]+(\(([^\n()=]+|\([^\n()=]+\))+\))?) *= *([^\n=>]):\1 = \4

# resuppression d'espaces sur indices boucles do et déclarations
(\n *(\d+ +|\w+ *; *)*do \w+) *= *:\1=

# suppression d'espaces avant/après parenthèses
\( +:(
 +\):)

# espacement entre parenthèse fermante et mot
\) *(\w):) \1

# conversion/espacement opérateurs binaires f77 et association/déclaration f90
 *(\.eq\.|==) *: == 
 *(\.ne\.|/=) *: \/= 
 *(\.le\.|<=) *: <= 
 *(\.ge\.|>=) *: >= 
 *(\.lt\.) *: < 
 *(\.gt\.) *: > 
 *=> *:=>
  *;; *([^\n]): ;; \1
([^= ]+) *\.(and|or|not|xor)\. *:\1.\2.

# espacement structures de controle
\<do *(while|concurrent)\>:do \1
(\n *else) *(if|where)\>:\1 \2
\<(if|where|while) *\(:\1 (

# espacement déclaration de variables sur types simples avec kind, types dérivées et class ('type(' = declaration variable)
(\n *(integer|real|double precision|character|complex|logical|type|class)) *\(:\1(

# espacement déclaration de type dérivés
\n+( *type\>[^(\n]+)\n+:\n\n\1\n

# suppression parenthèses inutiles : entre comparaison et .and. (2 fois), entre double () et en affectation
(\(|\.(and|x?or)\.)\(((\w+(\([^()"']+\))?|%| +|[/=<>]=|<|>|\.and\.|\.not\.)+)\)(\)|\.(and|x?or)\.):\1\3\6
(\(|\.(and|x?or)\.)\(((\w+(\([^()"']+\))?|%| +|[/=<>]=|<|>|\.and\.|\.not\.)+)\)(\)|\.(and|x?or)\.):\1\3\6
\((\([^()"']+\))\):\1
(\n *(\w+(\([^()"']+\))?|%)+) *= *\(([^()"']+)\) *\n:\1 = \4\n

# début d'unités de programme et interfaces + fonctions
(^|\n)\n* *(program|module|associate|((pure|impure|elemental|recursive) +)*subroutine|(abstract +)?interface)\> +([^\n]+)\n+:\1\n\2 \6\n
(^|\n)\n* *(((pure|impure|elemental|recursive|(integer|real|double precision|character|complex|logical|type|class)(\*\d+|\([^()]+\))?) +)*function)\> +([^\n]+)\n+:\1\n\2 \7\n

# début et alternatives de structures de contrôle
(\n *(\d+ +|\w+ *; *)*((do|select)\>[^\n]*|if\>[^\n]+\) *then\>|where\> *\(([^()"']+|(\(([^()"']+|\([^()"']+\))+\))+)+\)))\n+:\1\n
\n+( *else\>[^\n]*)\n+:\n\1\n

# suppression lignes vides en fin de structures et espacement 'end'
\n+( *end) *(do|if|where|select|module|function|subroutine|program|interface|type|associate)\>:\n\1 \2
\n+( *end)\>:\n\1

# suppression étiquettes structures 'do' Fortran 77
(\n *(\d+ +|\w+ *; *)*do) +([0-9]{1,5}) +(.+ *)\2 +continue\>:\1 \4end do

# suppression Dr Hook (use, call et variable z?hook_handle (pas les autres)
\n+ *if *\(lhook\) *(then\n+ *)?call +dr_hook *\([^()]+\)[^\n]*(\n+ *end *if\>[^\n]*)?:

# suppression espaces multiples
 {2,}: 

# suppression lignes vides multiples (début, fin et milieu de fichier)
^\n+:
\n+$:\n
\n{3,}:\n\n
